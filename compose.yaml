services:
  # MySQL Database
  mysql:
    image: mysql:8.0
    container_name: ems-mysql
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_NAME:-employee_management_system}
      MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD:-rootpassword}
      MYSQL_USER: ${DB_USERNAME:-emsuser}
      MYSQL_PASSWORD: ${DB_PASSWORD:-emspassword}
      TZ: UTC
    ports:
      - "${DB_PORT:-3307}:3306"
    volumes:
      - mysql_data:/var/lib/mysql
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    networks:
      - ems-network
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-p${DB_ROOT_PASSWORD:-rootpassword}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    command: --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci

  # Backend Application
  backend:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: ems-backend
    restart: unless-stopped
    environment:
      # Database Configuration
      # SPRING_DATASOURCE_URL can be set in .env to override default (uses 'mysql' service name by default)
      # Note: Docker Compose uses SERVICE NAME for DNS, not container name
      # Service name: 'mysql' (registered in DNS)
      # Container name: 'ems-mysql' (just a label, not used for DNS)
      # Note: Docker Compose doesn't support nested interpolation, so we use a hardcoded default
      # Spring Boot's application-prod.properties will handle DB_NAME substitution if needed
      DB_NAME: ${DB_NAME:-employee_management_system}
      SPRING_DATASOURCE_URL: ${SPRING_DATASOURCE_URL:-jdbc:mysql://mysql:3306/employee_management_system?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true&createDatabaseIfNotExist=true&autoReconnect=true&failOverReadOnly=false&maxReconnects=10&initialTimeout=2}
      # Note: Docker Compose doesn't support nested variable interpolation like ${VAR:-${OTHER:-default}}
      # Spring Boot's application-prod.properties handles the full fallback: SPRING_DATASOURCE_USERNAME -> DB_USERNAME -> emsuser
      # We also pass DB_USERNAME so Spring Boot can use it as fallback
      DB_USERNAME: ${DB_USERNAME:-emsuser}
      DB_PASSWORD: ${DB_PASSWORD:-emspassword}
      # Note: Spring Boot will use SPRING_DATASOURCE_PASSWORD if set, otherwise DB_PASSWORD
      # We pass both so Spring Boot can use the correct one
      # IMPORTANT: Make sure DB_PASSWORD in .env matches the password in MySQL!
      SPRING_DATASOURCE_USERNAME: ${SPRING_DATASOURCE_USERNAME:-emsuser}
      SPRING_DATASOURCE_PASSWORD: ${SPRING_DATASOURCE_PASSWORD:-emspassword}

      # JWT Configuration
      JWT_SECRET: ${JWT_SECRET:-changeThisToASecureRandomStringAtLeast256BitsForProductionUse}
      JWT_EXPIRATION: ${JWT_EXPIRATION:-86400000}

      # Email Configuration
      MAIL_HOST: ${MAIL_HOST:-smtp.gmail.com}
      MAIL_PORT: ${MAIL_PORT:-587}
      MAIL_USERNAME: ${MAIL_USERNAME}
      MAIL_PASSWORD: ${MAIL_PASSWORD}
      MAIL_SMTP_AUTH: ${MAIL_SMTP_AUTH:-true}
      MAIL_SMTP_STARTTLS_ENABLE: ${MAIL_SMTP_STARTTLS_ENABLE:-true}
      MAIL_SMTP_STARTTLS_REQUIRED: ${MAIL_SMTP_STARTTLS_REQUIRED:-true}
      MAIL_SMTP_SSL_TRUST: ${MAIL_SMTP_SSL_TRUST:-smtp.gmail.com}
      EMAIL_FROM_NAME: ${EMAIL_FROM_NAME:-Employee Management System}
      EMAIL_FROM_ADDRESS: ${EMAIL_FROM_ADDRESS:-${MAIL_USERNAME}}

      # Application Configuration
      APP_URL: ${APP_URL:-http://localhost}
      TESSERACT_DATA_PATH: /usr/share/tesseract-ocr/4.00/tessdata

      # CORS Configuration
      CORS_ALLOWED_ORIGINS: ${CORS_ALLOWED_ORIGINS:-http://localhost,http://localhost:80,http://localhost:4200}
      
      # OCR Configuration
      OCR_API_KEY: ${OCR_API_KEY:-}
      OCR_CLOUD_ENABLED: ${OCR_CLOUD_ENABLED:-false}
      OCR_LOCAL_ENABLED: ${OCR_LOCAL_ENABLED:-true}

      # Spring Profile
      SPRING_PROFILES_ACTIVE: prod
      
      # JPA Configuration - Ensure tables are created
      JPA_DDL_AUTO: ${JPA_DDL_AUTO:-update}
    ports:
      - "${BACKEND_PORT:-8080}:8080"
    volumes:
      - uploads_data:/app/uploads
    networks:
      - ems-network
    depends_on:
      mysql:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/api/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 120s

  # Frontend Application
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        API_URL: ${API_URL:-http://localhost:8080/api}
        API_BASE_URL: ${API_BASE_URL:-http://localhost:8080}
        FRONTEND_URL: ${FRONTEND_URL:-http://localhost}
    container_name: ems-frontend
    restart: unless-stopped
    ports:
      - "${FRONTEND_PORT:-80}:80"
    networks:
      - ems-network
    depends_on:
      - backend
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

volumes:
  mysql_data:
    driver: local
  uploads_data:
    driver: local

networks:
  ems-network:
    driver: bridge

