services:
  # MySQL Database
  mysql:
    image: mysql:8.0
    container_name: ems-mysql
    restart: unless-stopped
    # Resource limits for database operations
    # Optimized for 8GB RAM, 3 CPU system
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 1G
    environment:
      MYSQL_DATABASE: ${DB_NAME:-employee_management_system}
      MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD:-rootpassword}
      MYSQL_USER: ${DB_USERNAME:-emsuser}
      MYSQL_PASSWORD: ${DB_PASSWORD:-emspassword}
      TZ: UTC
    command: --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci --innodb-buffer-pool-size=512M --innodb-log-file-size=128M --innodb-flush-log-at-trx-commit=2 --max-connections=100
    ports:
      - "${DB_PORT:-3307}:3306"
    volumes:
      - mysql_data:/var/lib/mysql
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    networks:
      - ems-network
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-p${DB_ROOT_PASSWORD:-rootpassword}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  # Backend Application
  backend:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        BUILDKIT_INLINE_CACHE: 1
      network: host  # Use host network for better DNS resolution during build
    container_name: ems-backend
    restart: unless-stopped
    # Resource limits for document processing workloads
    # Optimized for 8GB RAM, 3 CPU system
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 3G
        reservations:
          cpus: '1.0'
          memory: 2G
    environment:
      # Database Configuration
      # SPRING_DATASOURCE_URL can be set in .env to override default (uses 'mysql' service name by default)
      # Note: Docker Compose uses SERVICE NAME for DNS, not container name
      # Service name: 'mysql' (registered in DNS)
      # Container name: 'ems-mysql' (just a label, not used for DNS)
      # Note: Docker Compose doesn't support nested interpolation, so we use a hardcoded default
      # Spring Boot's application-prod.properties will handle DB_NAME substitution if needed
      DB_NAME: ${DB_NAME:-employee_management_system}
      SPRING_DATASOURCE_URL: ${SPRING_DATASOURCE_URL:-jdbc:mysql://mysql:3306/employee_management_system?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true&createDatabaseIfNotExist=true&autoReconnect=true&failOverReadOnly=false&maxReconnects=10&initialTimeout=2}
      # Note: Docker Compose doesn't support nested variable interpolation like ${VAR:-${OTHER:-default}}
      # Spring Boot's application-prod.properties handles the full fallback: SPRING_DATASOURCE_USERNAME -> DB_USERNAME -> emsuser
      # We also pass DB_USERNAME so Spring Boot can use it as fallback
      DB_USERNAME: ${DB_USERNAME:-emsuser}
      DB_PASSWORD: ${DB_PASSWORD:-emspassword}
      # Note: Spring Boot will use SPRING_DATASOURCE_PASSWORD if set, otherwise DB_PASSWORD
      # We pass both so Spring Boot can use the correct one
      # IMPORTANT: Make sure DB_PASSWORD in .env matches the password in MySQL!
      SPRING_DATASOURCE_USERNAME: ${SPRING_DATASOURCE_USERNAME:-emsuser}
      SPRING_DATASOURCE_PASSWORD: ${SPRING_DATASOURCE_PASSWORD:-emspassword}

      # JWT Configuration
      JWT_SECRET: ${JWT_SECRET:-changeThisToASecureRandomStringAtLeast256BitsForProductionUse}
      JWT_EXPIRATION: ${JWT_EXPIRATION:-86400000}

      # Email Configuration
      # For Hostinger: Use smtp.hostinger.com with port 465 (SSL) or 587 (TLS)
      # Port 465 (SSL): Set MAIL_PORT=465, MAIL_SMTP_SSL_ENABLE=true, MAIL_SMTP_STARTTLS_ENABLE=false
      # Port 587 (TLS): Set MAIL_PORT=587, MAIL_SMTP_SSL_ENABLE=false, MAIL_SMTP_STARTTLS_ENABLE=true
      MAIL_HOST: ${MAIL_HOST:-smtp.gmail.com}
      MAIL_PORT: ${MAIL_PORT:-587}
      MAIL_USERNAME: ${MAIL_USERNAME}
      MAIL_PASSWORD: ${MAIL_PASSWORD}
      MAIL_SMTP_AUTH: ${MAIL_SMTP_AUTH:-true}
      MAIL_SMTP_STARTTLS_ENABLE: ${MAIL_SMTP_STARTTLS_ENABLE:-true}
      MAIL_SMTP_STARTTLS_REQUIRED: ${MAIL_SMTP_STARTTLS_REQUIRED:-true}
      MAIL_SMTP_SSL_ENABLE: ${MAIL_SMTP_SSL_ENABLE:-false}
      MAIL_SMTP_SSL_TRUST: ${MAIL_SMTP_SSL_TRUST:-smtp.gmail.com}
      MAIL_SMTP_SSL_SOCKET_FACTORY_PORT: ${MAIL_SMTP_SSL_SOCKET_FACTORY_PORT:-}
      EMAIL_FROM_NAME: ${EMAIL_FROM_NAME:-Employee Management System}
      EMAIL_FROM_ADDRESS: ${EMAIL_FROM_ADDRESS:-${MAIL_USERNAME}}

      # Application Configuration
      APP_URL: ${APP_URL:-https://vertexdigitalsystem.com}
      # Tesseract data path - will auto-detect if not found
      # Common paths: /usr/share/tesseract-ocr/5/tessdata (Tesseract 5.x) or /usr/share/tesseract-ocr/4.00/tessdata (Tesseract 4.x)
      TESSERACT_DATA_PATH: ${TESSERACT_DATA_PATH:-/usr/share/tesseract-ocr/5/tessdata}
      # TESSDATA_PREFIX environment variable for Tesseract native library
      # This is required for Tesseract to find language data files
      TESSDATA_PREFIX: ${TESSDATA_PREFIX:-${TESSERACT_DATA_PATH:-/usr/share/tesseract-ocr/5/tessdata}}

      # CORS Configuration
      CORS_ALLOWED_ORIGINS: ${CORS_ALLOWED_ORIGINS:-https://vertexdigitalsystem.com,https://www.vertexdigitalsystem.com,http://localhost:4200}
      
      # OCR Configuration
      OCR_API_KEY: ${OCR_API_KEY:-}
      OCR_CLOUD_ENABLED: ${OCR_CLOUD_ENABLED:-false}
      OCR_LOCAL_ENABLED: ${OCR_LOCAL_ENABLED:-true}

      # Spring Profile
      SPRING_PROFILES_ACTIVE: prod
      
      # JPA Configuration - Use 'validate' with Flyway (Flyway handles migrations)
      # Set to 'update' only if you want JPA to create tables (not recommended with Flyway)
      JPA_DDL_AUTO: ${JPA_DDL_AUTO:-validate}
      # Enable SQL logging for debugging (set to false in production)
      JPA_SHOW_SQL: ${JPA_SHOW_SQL:-false}
      JPA_FORMAT_SQL: ${JPA_FORMAT_SQL:-false}
    ports:
      - "${BACKEND_PORT:-8080}:8080"
    volumes:
      - uploads_data:/app/uploads
    networks:
      - ems-network
    depends_on:
      mysql:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/api/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 120s

  # Frontend Application
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        API_URL: ${API_URL:-https://vertexdigitalsystem.com/api}
        API_BASE_URL: ${API_BASE_URL:-https://vertexdigitalsystem.com}
        FRONTEND_URL: ${FRONTEND_URL:-https://vertexdigitalsystem.com}
      network: host  # Use host network for better DNS resolution during build
    container_name: ems-frontend
    restart: unless-stopped
    # Minimal resources for frontend (static files)
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
    ports:
      - "${FRONTEND_PORT:-80}:80"
      - "${FRONTEND_HTTPS_PORT:-443}:443"
    volumes:
      # Mount SSL certificates
      - ${SSL_DIR:-./ssl}:/etc/nginx/ssl:ro
      # Mount certbot webroot for Let's Encrypt challenges
      - certbot_webroot:/var/www/certbot:ro
    networks:
      - ems-network
    depends_on:
      - backend
    healthcheck:
      test: ["CMD-SHELL", "wget --quiet --tries=1 --spider https://localhost/ || wget --quiet --tries=1 --spider http://localhost/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

volumes:
  mysql_data:
    driver: local
  uploads_data:
    driver: local
  certbot_webroot:
    driver: local

networks:
  ems-network:
    driver: bridge

